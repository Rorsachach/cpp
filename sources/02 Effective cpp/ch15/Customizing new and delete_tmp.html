<!DOCTYPE html>
<html>
<head>
<title>Customizing new and delete.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E5%AE%9A%E5%88%B6%E7%9A%84-new-%E5%92%8C-delete">定制的 new 和 delete</h1>
<h2 id="%E6%9D%A1%E6%AC%BE49-%E4%BA%86%E8%A7%A3-new-handleer-%E7%9A%84%E8%A1%8C%E4%B8%BA">条款49: 了解 new-handleer 的行为</h2>
<hr>
<ul>
<li>set_new_handler 允许客户指定一个函数，在内存分配无法获得满足时被调用。</li>
<li>Nothrow new 是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用还是可能抛出异常。</li>
</ul>
<hr>
<p>当 operator new 无法满足某一内存分配需求时，它会抛出异常。对于旧式操作，该行为会返回一个 null
指针。我们可以通过修改错误处理函数来改变这种默认行为，从而获得旧式操作体验。</p>
<p>当 operator new 的行为无法被满足时，它会先调用一个客户指定的错误处理函数，所谓的 new-handler。
客户可以通过调用 set_new_handler 来指定函数。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span> {
  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*new_handler)</span> <span class="hljs-params">()</span></span>;
  <span class="hljs-function">new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 不抛出任何异常</span>
}
</div></code></pre>
<p>你可以这样设置 new-handler。</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;new&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outOfMem</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Unable to satisfy request for memory\n"</span>;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">abort</span>(); <span class="hljs-comment">// 终结</span>
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">std</span>::set_new_handler(outOfMem);
  <span class="hljs-keyword">int</span>* pBigDataArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10000000000L</span>];
}
</div></code></pre>
<p>当 operator new 无法满足内存申请时，它会不断调用 new-handler 函数，直到找到足够的内存。可
以将上面的 std::abort 注释掉尝试一下。</p>
<p>因此一个结论是，一个设计良好的 new-handler 函数必须做到以下的事情:</p>
<ul>
<li>让更多内存可以被使用: 这个策略的一个做法是，程序一开始执行就分配一大块内存，然后再 new-handler 第一次被调用时，将它们释放给程序使用。</li>
<li>安装另一个 new-handler: 如果当前这个 new-handler 无法获取更多的可用内存，或许它直到另外哪个 new-handler 有此能力，如果是这样可以对 new-handler 进行替换。</li>
<li>卸除 new-handler: 将 null 指针传给 set_new_handler，一旦没有安装任何 new-handler，operator new 会在内存分配不成功时抛出异常。</li>
<li>不返回: 直接调用 abort 或者 exit。</li>
</ul>
<p>有时，我们希望能够根据不同的 class 来执行专属的内存分配失败处理函数。c++ 并不支持 class 专
属的 new-handlers，但是可以为每一个 class 提供自己的 set_new_handler 和 operator new。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewHandlerHolder</span> {</span> <span class="hljs-comment">// RAII</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">NewHandlerHolder</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::new_handler nh)</span> : <span class="hljs-title">handler</span><span class="hljs-params">(nh)</span> </span>{}
  ~NewHandlerHolder() {
    <span class="hljs-built_in">std</span>::set_new_handler(handler);
  }
<span class="hljs-keyword">private</span>:
  <span class="hljs-built_in">std</span>::new_handler handler;
  NewHandlerHolder(<span class="hljs-keyword">const</span> NewHandlerHolder&amp;); <span class="hljs-comment">// 阻止 copying 发生</span>
  NewHandlerHolder&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> NewHandlerHolder&amp;); 
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> {</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bad_alloc)</span></span>;
<span class="hljs-keyword">private</span>:
  <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::new_handler currentHandler;
};

<span class="hljs-built_in">std</span>::new_handler currentHandler = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-built_in">std</span>::new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">std</span>::new_handler oldHandler = currentHandler;
  crrentHandler = p;
  <span class="hljs-keyword">return</span> oldHandler;
}
<span class="hljs-function"><span class="hljs-keyword">void</span>* Widget::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bad_alloc)</span> </span>{
  <span class="hljs-function">NewHandlerHolder <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::set_new_handler(currentHandler))</span></span>; <span class="hljs-comment">// 返回时自动销毁，并在析构函数中重新绑定默认的 new_handler</span>
  <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size); <span class="hljs-comment">// 调用 global operator new</span>
}
</div></code></pre>
<p>上述代码可以进行一般化处理，采用复合的方式来构建。简单的做法是简历一个 “mixin” 风格的 base
class，这种 base class 用来允许 derived class 继承单一特定的能力。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewHandlerSupport</span> {</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bad_alloc)</span></span>;
<span class="hljs-keyword">private</span>:
  <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::new_handler currentHandler;
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-built_in">std</span>::new_handler NewHandlerSupport&lt;T&gt;::set_new_handler(<span class="hljs-built_in">std</span>::new_handler p) <span class="hljs-keyword">throw</span>() {
  <span class="hljs-built_in">std</span>::new_handler oldHandler = currentHandler;
  crrentHandler = p;
  <span class="hljs-keyword">return</span> oldHandler;
}
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span>* NewHandlerSupport&lt;T&gt;::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bad_alloc)</span> </span>{
  <span class="hljs-function">NewHandlerHolder <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::set_new_handler(currentHandler))</span></span>; <span class="hljs-comment">// 返回时自动销毁，并在析构函数中重新绑定默认的 new_handler</span>
  <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size); <span class="hljs-comment">// 调用 global operator new</span>
}
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-built_in">std</span>::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = <span class="hljs-number">0</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> :</span> <span class="hljs-keyword">public</span> NewHandlerSupport&lt;Widget&gt; { <span class="hljs-comment">// 不再需要提供 set_new_handler 和 operator new</span>
  ...
};
</div></code></pre>
<p>上面的 T 只是为了区分类型，而没有特殊含义。这种行为叫做 curiously recurring template pattern; CRTP。</p>
<p>现在大多数的 operator new 实现，如果空间不足都会抛出 bad_alloc 异常。但是也可以支持返回
null 的方法。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> {</span>};
Widget* pw1 = <span class="hljs-keyword">new</span> Widget(); <span class="hljs-comment">// 如果分配失败，抛出 bad_alloc</span>
<span class="hljs-keyword">if</span> (pw1 == <span class="hljs-number">0</span>) ... <span class="hljs-comment">// 没必要，因为一定 pw1 不可能为0</span>

Widget* pw2 = <span class="hljs-keyword">new</span> (<span class="hljs-built_in">std</span>::nothrow) Widget(); <span class="hljs-comment">// 失败，返回0</span>
<span class="hljs-keyword">if</span> (pw2 == <span class="hljs-number">0</span>) ... <span class="hljs-comment">// 可能成功</span>
</div></code></pre>
<p>然而这种方式完全没必要，因为 nothrow 之后限制 operator new 抛出异常，而当 constructor 抛
出异常仍然会传播。</p>
<h2 id="%E6%9D%A1%E6%AC%BE50-%E4%BA%86%E8%A7%A3-new-%E5%92%8C-delete-%E7%9A%84%E5%90%88%E7%90%86%E6%9B%BF%E6%8D%A2%E6%97%B6%E6%9C%BA">条款50: 了解 new 和 delete 的合理替换时机</h2>
<hr>
<ul>
<li>有许多理由需要写个自定的 new 和 delete，包括改善效能、对 heap 运用错误进行调试、收集 heap 使用信息</li>
</ul>
<hr>
<p>为什么会想要替换编译器提供的 operator new 或者 operator delete？</p>
<ul>
<li>用来检测运用上的错误。</li>
<li>为了强化效能。</li>
<li>为了收集使用上的统计数据。</li>
</ul>
<p>一个定制 operator new 的例子，用于促进并协助检查 &quot;overruns&quot;(写入点再分配区块之后) 或
&quot;underruns&quot;(写入点再分配区块之前)。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> signature = <span class="hljs-number">0xDEADBEEF</span>;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> Byte;
<span class="hljs-comment">// 下列代码仍然存在错误</span>
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-title">throw</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::bad_alloc)</span> </span>{
  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
  <span class="hljs-keyword">size_t</span> realSize = size + <span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>); <span class="hljs-comment">// 增加两个空间用来存放 两个 signature</span>

  <span class="hljs-keyword">void</span>* pMem = <span class="hljs-built_in">malloc</span>(realSize); <span class="hljs-comment">// 调用 malloc 取得内存</span>
  <span class="hljs-keyword">if</span> (!pMem) <span class="hljs-keyword">throw</span> bad_alloc(); <span class="hljs-comment">// 如果为空就抛出 bad_alloc</span>

  <span class="hljs-comment">// 将 signature 写入内存的最前和最后</span>
  *(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>*&gt;(pMem)) = signature;
  *(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">int</span>*&gt;(<span class="hljs-keyword">static_cast</span>&lt;Byte*&gt;(pMem) + realSize - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>))) = signature;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;Byte*&gt;(pMem) + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>); <span class="hljs-comment">// 返回 signature 之后的内存位置</span>
}
</div></code></pre>
<h3 id="%E5%AF%B9%E9%BD%90">对齐</h3>
<p>这里强调一下 对齐 问题。在计算机体系结构中，如果对齐条件满足，通常是效率较高的。比如一个 double
如果是 8-byte，当它正好与地址的 8-byte 位置对齐时效率时最高的。通常使用 malloc 获得的地址
是满足对齐的。但是上述代码中，我们显然返回的不是原始 pointer，而是一个后移了 4-byte 的指针。
这时就可能获得的是一个没有适当对齐的指针，那么可能会造成程序崩溃或者执行速度缓慢。</p>
<p>有时好的效率是必要的，但是很多时候这也没有太大影响。</p>
<p>那么究竟何时需要替换缺省的 new 和 delete 呢？</p>
<ul>
<li>为了检测运用错误。</li>
<li>为了收集动态分配内存之使用统计信息。</li>
<li>为了增加分配和归还的速度。</li>
<li>为了降低缺省内存管理器带来的空间额外开销。</li>
<li>为了弥补缺省分配器中的非最佳对齐。</li>
<li>为了将相关对象成簇集中。</li>
<li>为了获得非传统行为。</li>
</ul>
<h2 id="%E6%9D%A1%E6%AC%BE51-%E7%BC%96%E5%86%99-new-%E5%92%8C-delete-%E6%97%B6%E9%9C%80%E8%A6%81%E5%9B%BA%E5%AE%88%E5%B8%B8%E8%A7%84">条款51: 编写 new 和 delete 时需要固守常规</h2>
<hr>
<ul>
<li>operator new 应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用 new-handler。它在应该有能力处理 0 bytes 申请。Class 专属版本则还应该处理 “比正确大小更大的申请”。</li>
<li>operator delete 应该在收到 null 指针时不做任何事。Class 专属版本则还应该处理 “比正确大小更大的申请”。</li>
</ul>
<hr>
<p>编写自己的 operator new 和 operator delete 时应该遵守哪些规矩。</p>
<h3 id="operator-new">operator new</h3>
<p>实现一致性的 operator new 1. 必须得返回正确的值，2. 内存不足时必须得调用 new-handling 函
数，3. 必须有能够对付零内存需求的准备，4. 避免不慎掩盖正常形式的 new。</p>
<p>operator new 的返回值非常简单，如果有能力就返回内存指针，没有则抛出 bad_alloc 异常。</p>
<p>一个 operator new 的伪代码:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bad_alloc)</span> </span>{
  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
  <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 用来处理 申请 0-bytes 内存的行为</span>
    size = <span class="hljs-number">1</span>;
  }
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    尝试分配 size bytpes;
    <span class="hljs-keyword">if</span> (成功) 
      <span class="hljs-keyword">return</span> pointer;
    
    <span class="hljs-comment">// 分配失败</span>
    new_handler globalHandler = set_new_handler(<span class="hljs-number">0</span>); <span class="hljs-comment">// 获取当前的 new-handling 函数</span>
    set_new_handler(globalHandler);
    
    <span class="hljs-keyword">if</span> (globalHandler) <span class="hljs-comment">// 如果 globalHandler 不为空就执行</span>
      (*gloablHandler)();
    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 否则默认抛出异常</span>
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::bad_alloc();
  }
}
</div></code></pre>
<p>但是上述代码有一个小缺点，就是会影响 derived class。而通常我们重写 operator new 实际上是
为了能够针对某个特定 class 进行优化，而非其它 derived class。一种好的方法是，在operator new
中进行判断大小。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span>* Base::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bad_alloc)</span> </span>{
  <span class="hljs-keyword">if</span>(size != <span class="hljs-keyword">sizeof</span>(Base))
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);
}
</div></code></pre>
<p>这不仅包括了对类型的判断，也包括了对 size == 0 的判断，因为 c++ 中独立对象必须有大小，因此
sizeof(Base) 不可能为0。</p>
<p>对于 operator new[] 来分配数组，唯一需要做的就是分配一块未加工的内存，其他计算空间大小等工
作都不应该在此处进行。</p>
<h3 id="operator-delete">operator delete</h3>
<p>operator delete 情况十分简单，只需要记住的唯一一件事情，就是保证 “删除 null 指针永远安全”。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* rawMemory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">if</span> (rawMemory == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;

  <span class="hljs-comment">// 归还 rawMemory 内存。</span>
}
</div></code></pre>
<p>member 版本也十分简单，和 operator new 一样进行类型判断即可。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span>* Base::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* rawMemory, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">if</span> (rawMemory == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">if</span>(size != <span class="hljs-keyword">sizeof</span>(Base)) {
    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(rawMemory)</span></span>;
    <span class="hljs-keyword">return</span>;
  }
  ...
}
</div></code></pre>
<p>另外，如果即将被删除的对象派生自某个 base class 而后者欠缺 virtual 析构函数，那么 c++ 传给
operator delete 的 size_t 数值可能不正确。</p>
<h2 id="%E6%9D%A1%E6%AC%BE52-%E5%86%99%E4%BA%86-placement-new-%E4%B9%9F%E8%A6%81%E5%86%99-placement-delete">条款52: 写了 placement new 也要写 placement delete</h2>
<hr>
<ul>
<li>当你写一个 placement operator new，请确定也写出了对应的 placement operator delete。如果没有这样做，你的程序可能会发生时断时续的内存泄露。</li>
<li>当你声明 placement new 和 placement delet，请确定不要无疑是的遮掩他们的正常版本。</li>
</ul>
<hr>
<p>new operator 总是分为两步进行的，首先调用 operator new 进行空间申请，而第二步则是执行 constructor。
如果后者出错，那么 operator new 所分配的地址空间应该怎样做？答案必然是被释放以防止内存泄露。
但是有个问题，就是编译器怎么找到对应的 operator delete 呢？</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> {</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::ostream&amp; logStream)</span></span>; <span class="hljs-comment">// 非正常形式的 new</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* pMemory)</span></span>; <span class="hljs-comment">// 正常形式的 new</span>
};

{
  Widget* pw = <span class="hljs-keyword">new</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span>) Widget;
}
</div></code></pre>
<p>实际上编译器会选择同调用的 operator new 最相像的 operator delete 进行调用，也就是说寻找
参数个数和类型都与 operator new 相同的某个 operator delete。例如上面这段代码，当 Widget
constructor 发生异常后就会调用 operator delete(std::size_t size, std::ostream&amp; logStream);
而上面没有定义就会产生另一个异常最终导致 abort。</p>
<p>而在正常的主动删除情况下，可以直接 delete 即可，而此时并不会去调用与 operator new 对应版本
的 operator delete。</p>
<p>所以为了保证内存安全，你应该随时虽可提供相应形式的 delete。这和 placement new/delete 成对
设计的道理相同。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> {</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::ostream&amp; logStream)</span></span>; <span class="hljs-comment">// 非正常形式的 new</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* pMemory)</span></span>; <span class="hljs-comment">// 正常形式的 new</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* pMemory, <span class="hljs-built_in">std</span>::ostream&amp; logStream)</span></span>;
};

{
  Widget* pw = <span class="hljs-keyword">new</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span>) Widget;
}
</div></code></pre>
<p>需要注意的一点是，重新定义 operator new/delete 是会进行名称掩盖的。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> {</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::ostream&amp; logStream)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bad_alloc)</span></span>;
};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base {
<span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bad_alloc)</span></span>;
};

Base* pb = <span class="hljs-keyword">new</span> Base; <span class="hljs-comment">// 错误，global 被掩盖了</span>
Base* pb = <span class="hljs-keyword">new</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span>) Base; <span class="hljs-comment">// 正确</span>

Derived* pd = <span class="hljs-keyword">new</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">clog</span>) Derived; <span class="hljs-comment">// 错误，Base 被掩盖掉了</span>
Derived* pd = <span class="hljs-keyword">new</span> Derived; <span class="hljs-comment">// 正确</span>
</div></code></pre>
<p>如果你不希望这些默认行为发生掩盖呢？你可以按照下面这样进行设计。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardNewDeleteForms</span> {</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-comment">// normal new/delete</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bad_alloc)</span> </span>{
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);
  }
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* pMemory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>{
    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory)</span></span>;
  }

  <span class="hljs-comment">// placement new/delete</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bad_alloc)</span> </span>{
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size, ptr);
  }
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* pMemory, <span class="hljs-keyword">void</span>* ptr)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>{
    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory, ptr)</span></span>;
  }

  <span class="hljs-comment">// nothrow new/delete</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nt)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size, nt);
  }
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* pMemory, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::nothrow&amp; nt)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>{
    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory)</span></span>;
  }
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> :</span> <span class="hljs-keyword">public</span> StandardNewDeleteForms {
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> StandardNewDeleteForms::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>;
  <span class="hljs-keyword">using</span> StandardNewDeleteForms::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>;
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::ostream&amp; logStream)</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bad_alloc)</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* pMemory, <span class="hljs-built_in">std</span>::ostream&amp; logStream)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;
};
</div></code></pre>
<p>利用继承机制和 using 声明式来取得标准形式。</p>

</body>
</html>
