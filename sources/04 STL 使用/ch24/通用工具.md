## 通用工具

## 1. pairs
class pair 可以将两个值视为一个单元，比较常见的使用案例是 map 和 multimap 通过 pair 来管
理 key/value 结构。

[pair 实现](https://github.com/google/libcxx/blob/27c836ff3a9c505deb9fd1616012924de8ff9279/include/utility)

pair 被定义为 struct 意味着所有成员都是 public 的。其中的 copy constructor 是 template 
形式，是因为可能发生隐式类型转换。

### pair 之间的比较
STL 为 pair 提供了管用的操作符，如果两个 pair 对象内的所有元素都相等，那么这两个 pair 会被
视为相等。比较顺序是先 first 后 second。

### make_pair
make_pair 可以无需写出类型就生成一个 pair 对象。这一点在进行函数调用时最方便使用。

```cpp
std::pair<int, float>(42, 7.77);
std::make_pair(42, 7.77); \\ 更简单
```

## 2. class auto_ptr
auto_ptr 是一种智能型指针，可以帮助程序员防止 “被异常抛出时发生资源泄露”。

### auto_ptr 的设计动机
以下是一个通常带有资源变量的函数写法。

```cpp
void f() {
  A* ptr = new A();
  ...
  delete ptr;
}
```

上面这段代码可能出现的问题是，程序员很有可能会忘记 delete 操作，导致资源没有被释放而产生资源
泄露。除了普通资源泄露问题之外，有一个更大的隐患在于当异常发生时，如果发生异常更容易忘记进行资
源释放。

```cpp
void f() {
  A* ptr = new A();
  try {

  } catch(...) {
    delete ptr; // 发生异常时也要释放资源
    throw;
  }
  delete ptr;
}
```

智能型指针可以在 scoop 结束时自动销毁，就和局部变量一样，这一点很好的解决了资源泄露的问题。

```cpp
void f() {
  std::auto_ptr<A> ptr(new A);
  ...
}
```

但是需要注意，auto_ptr<> 不允许使用一般指针惯用的赋值操作进行初始化。

```cpp
std::auto_ptr<A> ptr1(new A);
std::auto_ptr<A> ptr2 = ptr1; // 错误
```

### auto_ptr 拥有权转移
auto_ptr 所界定的是一种严格的拥有权观念，那么不要让同一个对象为初值将两个 auto_ptr 初始化。
这个条件还会导致一个问题：auto_ptr 的 copy constructor 和 assignment 操作符会将所有权交
出而非简单的进行数据复制。

```cpp
std::auto_ptr<A> ptr1(new A);
std::auto_ptr<A> ptr2(ptr1); // ptr2 拥有了 ptr1 原来所拥有的数据，而 ptr1 指向了 null
```

### 起点和终点
因为 auto_ptr 的拥有权可以进行转移，所以可以有两种特殊用法：

1. 数据终点
如果某个函数作为数据终点出现，它以 by value 方式接收一个 auto_ptr 并不再传出。

```cpp
void sink(std::auto_ptr<A>);
```

2. 数据起点
如果某个函数作为数据起点，它会以 by value 的方式返回一个 auto_ptr，这意味着产生了一个数据。

```cpp
std::auto_ptr<A> f() {
  std::auto_ptr<A> ptr(new A);
  ...
  return ptr;
}
```

这样做，也不会造成数据泄露，如果使用传统的 new 进行数据分配就很容易造成数据的泄露。

### 缺陷
auto_ptr 的语义本身就具有拥有权，如果无意转交该拥有权，就不要使用 auto_ptr，否则可能会产生
灾难。

```cpp
template <class T>
void bad_print(std::auto_ptr<T> p) {
  if (p.get() == nullptr) {
    std::cout << "nullptr";
  } else {
    std::cout << *p;
  }
}

std::auto_ptr<int> p(new int);
*p = 42;
bad_print(p);
*p = 18; // 错误，因为拥有权已经被交出
```

也许你会想要使用 reference 来操作，但是对于 auto_ptr 而言，这种操作时没有被定义的。如果你
不想交出拥有权又想使用 auto_ptr，将它声明为 const 的，让所有问题暴露在编译期。

```cpp
const std::auto_ptr<int> p(new int);
*p = 42;
bad_print(p); // 编译错误，因为不能将 const 转向 non-const reference
*p = 18; 
```



